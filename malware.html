<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Malware Simulation — Worms / Trojans / Virus</title>

  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg-1:#0f1724;
      --bg-2:#071024;
      --card: rgba(255,255,255,0.04);
      --muted: #9ca3af;
      --glass: rgba(255,255,255,0.03);
      --accent: linear-gradient(90deg,#06b6d4,#7c3aed);
      --success:#10b981;
      --danger:#ef4444;
      --warn:#f59e0b;
      --patch:#60a5fa;
      --glass-border: rgba(255,255,255,0.06);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background: radial-gradient(800px 400px at 10% 10%, rgba(124,58,237,0.12), transparent),
                  radial-gradient(700px 350px at 90% 90%, rgba(6,182,212,0.06), transparent),
                  linear-gradient(180deg,var(--bg-1),var(--bg-2));
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      padding:28px;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:20px;
      min-height: calc(100vh - 56px);
    }

    /* header */
    .topbar{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:16px;
      margin-bottom:6px;
    }
    .title{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo{
      width:56px;height:56px;border-radius:10px;
      background:linear-gradient(135deg,#7c3aed,#06b6d4);
      display:grid;place-items:center;font-weight:700;color:white;font-size:18px;
      box-shadow:0 6px 20px rgba(6,182,212,0.08);
    }
    h1{margin:0;font-size:20px}
    .subtitle{color:var(--muted);font-size:13px}

    /* main canvas card */
    .canvasCard{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid var(--glass-border);
      border-radius:var(--radius);
      padding:14px;
      height:calc(100vh - 170px);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }

    /* animated subtle grid background */
    .canvasCard::before{
      content:"";
      position:absolute; inset:0; z-index:0;
      background-image:linear-gradient(transparent, rgba(255,255,255,0.01));
      pointer-events:none;
    }

    #netSvg{
      width:100%;
      height:100%;
      background: repeating-linear-gradient(45deg, rgba(255,255,255,0.006) 0 1px, transparent 1px 30px);
      border-radius:10px;
      display:block;
      position:relative;
      z-index:1;
    }

    /* tooltip */
    .tooltip{
      position:absolute;
      pointer-events:none;
      background:rgba(2,6,23,0.85);
      padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
      font-size:13px;color:#dbeafe;z-index:5;transform:translate(-50%,-130%);
      white-space:nowrap;display:none;
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
    }

    /* sidebar */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:14px;
      border:1px solid var(--glass-border);
      height:calc(100vh - 170px);
      overflow:auto;
    }
    .row{display:flex;justify-content:space-between;align-items:center}
    .small{color:var(--muted);font-size:13px}
    .smallMuted{color:#94a3b8;font-size:12px}
    .infoBox{background:var(--card);padding:12px;border-radius:10px;margin-top:10px;border:1px solid rgba(255,255,255,0.02)}
    .controlsGrid{display:flex;flex-direction:column;gap:10px}
    .rangeRow{display:flex;flex-direction:column;gap:6px}
    input[type="range"]{width:100%}
    .btn{
      display:inline-flex;align-items:center;gap:8px;justify-content:center;
      padding:10px 12px;border-radius:10px;border:none;background:linear-gradient(90deg,#0ea5a6,#7c3aed);
      color:white;font-weight:600;cursor:pointer;font-size:14px;
      box-shadow:0 6px 18px rgba(124,58,237,0.12);transition:transform .12s ease,filter .12s;
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04); box-shadow:none}
    .btn.ghost:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}

    .modes{display:flex;gap:8px;flex-wrap:wrap}
    .modeBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--muted)}
    .modeBtn.active{background:linear-gradient(90deg,#1f2937,#0b1220);border:1px solid rgba(124,58,237,0.45);color:#e6eef8;box-shadow:0 8px 30px rgba(7,11,20,0.6)}

    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .badge{display:flex;gap:8px;align-items:center;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    .statusDot{width:10px;height:10px;border-radius:50%;display:inline-block;box-shadow:0 3px 8px rgba(2,6,23,0.6)}

    .note{color:var(--muted);font-size:12px;margin-top:10px}

    .statRow{display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.02)}
    .statNum{font-weight:700;color:#e6eef8}

    .footerSmall{margin-top:12px;color:var(--muted);font-size:12px}

    /* bottom footer single row */
    .footer{
      grid-column:1 / -1;
      margin-top:10px;
      color:var(--muted);font-size:12px;text-align:center;
    }

    /* responsive */
    @media (max-width:980px){
      .wrap{grid-template-columns:1fr; padding-bottom:20px}
      .canvasCard{height:60vh}
      .panel{height:auto}
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="topbar">
      <div class="title">
        <div class="logo">ALA2</div>
        <div>
          <h1>Malware Simulation — Click a mode to run</h1>
          <div class="subtitle">Worms • Trojan Horse • Virus — interactive network demo for educational use</div>
        </div>
      </div>

      <div style="display:flex;gap:10px;align-items:center">
        <div class="modes">
          <button class="modeBtn active" id="modeWorms">Worms</button>
          <button class="modeBtn" id="modeTrojan">Trojan</button>
          <button class="modeBtn" id="modeVirus">Virus</button>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn ghost" id="pauseBtn">Pause</button>
          <button class="btn ghost" id="resetBtn">Reset</button>
        </div>
      </div>
    </div>

    <!-- Canvas area -->
    <div class="canvasCard" id="canvasWrap">
      <svg id="netSvg" viewBox="0 0 900 540" preserveAspectRatio="xMidYMid meet"></svg>
      <div id="tooltip" class="tooltip"></div>
    </div>

    <!-- Sidebar -->
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Mode explanation</div>
        <div class="small">Current: <strong id="currentMode">Worms</strong></div>
      </div>

      <div id="modeInfo" class="infoBox">
        <div style="font-weight:700;margin-bottom:6px">Worms — network propagation</div>
        <div class="small">Worms scan neighbors and automatically attempt lateral movement across edges. Adjust infection and patch rates to observe outcomes.</div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Simulation controls</div>
        <div class="infoBox" style="padding:10px;margin-top:8px">
          <div class="controlsGrid">
            <div class="rangeRow">
              <div class="smallMuted">Worm infect rate <span id="wormRateLabel">0.50</span></div>
              <input id="wormRate" type="range" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="rangeRow">
              <div class="smallMuted">Trojan click success <span id="trojanRateLabel">0.40</span></div>
              <input id="trojanRate" type="range" min="0" max="1" step="0.01" value="0.4">
            </div>

            <div class="rangeRow">
              <div class="smallMuted">Patch rate / tick <span id="patchRateLabel">0.15</span></div>
              <input id="patchRate" type="range" min="0" max="0.5" step="0.01" value="0.15">
            </div>

            <div class="rangeRow">
              <div class="smallMuted">Tick speed (ms) <span id="speedLabel">600</span></div>
              <input id="speedRange" type="range" min="120" max="1500" step="30" value="600">
            </div>
          </div>

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="spawnTrojan" class="btn" style="flex:1">Deploy Trojan</button>
            <button id="seedInfected" class="btn ghost" style="flex:1">Seed Infection</button>
          </div>

          <div style="display:flex;gap:8px;margin-top:8px">
            <div style="flex:1">
              <div class="smallMuted">Network size</div>
              <input id="netSize" type="range" min="6" max="80" step="1" value="20">
            </div>
            <div style="width:120px">
              <div class="smallMuted">Auto-seed</div>
              <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                  <input id="autoSeedToggle" type="checkbox" checked>
                  <span class="smallMuted">Auto-seed count</span>
                </label>
                <div id="autoSeedCount" class="smallMuted" style="min-width:28px;text-align:center">1</div>
              </div>
            </div>
          </div>

        </div>

        <div class="legend">
          <div class="badge"><span class="statusDot" style="background:var(--success)"></span> Healthy</div>
          <div class="badge"><span class="statusDot" style="background:var(--danger)"></span> Infected</div>
          <div class="badge"><span class="statusDot" style="background:var(--warn)"></span> Compromised</div>
          <div class="badge"><span class="statusDot" style="background:var(--patch)"></span> Patched</div>
        </div>

        <div class="note">Click a node to simulate user action. Trojan files appear as small yellow squares near nodes — clicking them triggers a social-engineer vector that may compromise the host.</div>
      </div>

      <div style="margin-top:10px">
        <div class="small">Live stats</div>
        <div class="infoBox" id="statsBox">
          <div class="statRow"><div>Healthy</div><div class="statNum" id="statHealthy">0</div></div>
          <div class="statRow"><div>Infected</div><div class="statNum" id="statInfected">0</div></div>
          <div class="statRow"><div>Compromised</div><div class="statNum" id="statCompromised">0</div></div>
          <div class="statRow"><div>Patched</div><div class="statNum" id="statPatched">0</div></div>
          <div class="smallMuted" style="margin-top:8px">Tick count: <span id="tickCount">0</span></div>
          <canvas id="spark" width="320" height="50" style="width:100%;margin-top:10px;border-radius:6px;background:transparent"></canvas>
        </div>
      </div>

      <div class="footerSmall" style="margin-top:14px">Run locally: pip install flask • python app.py • open http://127.0.0.1:5000</div>

    </div>

    <div class="footer">This is an educational simulation. It abstracts complex real-world behaviors into simple rules — useful for intuition but not for attack replication.</div>

  </div>

  <!-- Simulation script -->
  <script>
    /* Simple interactive simulation controlling UI + network draw + basic rules.
       Not an accurate replication — intended for education & experimentation.
    */

    /* --- UI elements --- */
    const svg = document.getElementById('netSvg');
    const tooltip = document.getElementById('tooltip');

    const modeBtns = {
      worms: document.getElementById('modeWorms'),
      trojan: document.getElementById('modeTrojan'),
      virus: document.getElementById('modeVirus')
    };
    const currentModeLabel = document.getElementById('currentMode');
    const modeInfo = document.getElementById('modeInfo');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');

    const wormRateInput = document.getElementById('wormRate');
    const trojanRateInput = document.getElementById('trojanRate');
    const patchRateInput = document.getElementById('patchRate');
    const speedRange = document.getElementById('speedRange');
    const netSizeRange = document.getElementById('netSize');
    const seedBtn = document.getElementById('seedInfected');
    const spawnTrojanBtn = document.getElementById('spawnTrojan');

    const wormRateLabel = document.getElementById('wormRateLabel');
    const trojanRateLabel = document.getElementById('trojanRateLabel');
    const patchRateLabel = document.getElementById('patchRateLabel');
    const speedLabel = document.getElementById('speedLabel');
    const autoSeedToggle = document.getElementById('autoSeedToggle');
    const autoSeedCount = document.getElementById('autoSeedCount');

    const statHealthy = document.getElementById('statHealthy');
    const statInfected = document.getElementById('statInfected');
    const statCompromised = document.getElementById('statCompromised');
    const statPatched = document.getElementById('statPatched');
    const tickCountEl = document.getElementById('tickCount');

    const spark = document.getElementById('spark');
    const sctx = spark.getContext('2d');

    /* --- Simulation state --- */
    let mode = 'worms'; // worms | trojan | virus
    let nodes = [];
    let edges = [];
    let tick = 0;
    let running = false;
    let timer = null;

    // parameters
    function params(){
      return {
        wormRate: parseFloat(wormRateInput.value),
        trojanRate: parseFloat(trojanRateInput.value),
        patchRate: parseFloat(patchRateInput.value),
        speed: parseInt(speedRange.value,10),
        netSize: parseInt(netSizeRange.value,10),
        autoSeed: autoSeedToggle.checked,
        autoSeedCount: Math.max(1, Math.round(netSizeRange.value/20))
      }
    }

    /* --- helpers --- */
    function rand(min=0,max=1){ return Math.random()*(max-min)+min }
    function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

    /* --- create network --- */
    function buildNetwork(n){
      nodes = [];
      edges = [];
      const w = svg.viewBox.baseVal.width || 900;
      const h = svg.viewBox.baseVal.height || 540;

      // layout: random positions, not too close to edges
      for(let i=0;i<n;i++){
        nodes.push({
          id:i,
          x:rand(40,w-40),
          y:rand(40,h-40),
          status:'healthy', // healthy, infected, compromised, patched
          trojans:0, // number of trojan files near node
          elem:null, // svg group
        });
      }

      // edges: connect to nearest neighbours
      const maxConn = clamp(Math.round(n/4),2,10);
      for(let i=0;i<n;i++){
        // compute distances
        const arr = [];
        for(let j=0;j<n;j++){
          if(i===j) continue;
          const dx = nodes[i].x-nodes[j].x;
          const dy = nodes[i].y-nodes[j].y;
          const d = Math.hypot(dx,dy);
          arr.push({j,d});
        }
        arr.sort((a,b)=>a.d-b.d);
        for(let k=0;k<maxConn;k++){
          if(!arr[k]) break;
          const j = arr[k].j;
          // add undirected edge once
          const key = `${Math.min(i,j)}-${Math.max(i,j)}`;
          if(!edges.find(e=>e.key===key)){
            edges.push({a:i,b:j,key,d:arr[k].d});
          }
        }
      }

      renderNetwork();
    }

    /* --- render network --- */
    function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild) }
    function renderNetwork(){
      clearSVG();

      // draw edges first
      edges.forEach(e=>{
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        const a = nodes[e.a], b = nodes[e.b];
        line.setAttribute('x1',a.x); line.setAttribute('y1',a.y);
        line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
        line.setAttribute('stroke','rgba(255,255,255,0.04)');
        line.setAttribute('stroke-width','1.0');
        svg.appendChild(line);
        e.elem = line;
      });

      // draw node groups
      nodes.forEach(n=>{
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform',`translate(${n.x},${n.y})`);
        g.style.cursor='pointer';

        // ring
        const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');
        ring.setAttribute('r',14);
        ring.setAttribute('fill','none');
        ring.setAttribute('stroke','rgba(255,255,255,0.03)');
        ring.setAttribute('stroke-width','2');
        g.appendChild(ring);

        // main circle
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('r',10);
        c.setAttribute('fill','#0b1220');
        c.setAttribute('stroke','rgba(255,255,255,0.02)');
        c.setAttribute('stroke-width','1.5');
        g.appendChild(c);

        // small status indicator
        const status = document.createElementNS('http://www.w3.org/2000/svg','circle');
        status.setAttribute('r',5);
        status.setAttribute('cx',10);
        status.setAttribute('cy',-10);
        status.setAttribute('fill','#10b981');
        g.appendChild(status);

        // trojan square (appears if trojans>0)
        const trojanRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        trojanRect.setAttribute('x',-22);
        trojanRect.setAttribute('y',-22);
        trojanRect.setAttribute('width',8);
        trojanRect.setAttribute('height',8);
        trojanRect.setAttribute('rx',2);
        trojanRect.setAttribute('fill','#facc15');
        trojanRect.setAttribute('opacity','0');
        g.appendChild(trojanRect);

        // labels hidden
        const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
        lab.textContent = `#${n.id}`;
        lab.setAttribute('x',14); lab.setAttribute('y',18);
        lab.setAttribute('font-size','10'); lab.setAttribute('fill','#9fb2d7');
        lab.setAttribute('opacity','0.0');
        g.appendChild(lab);

        // event handlers
        g.addEventListener('mouseenter', (ev)=>{
          tooltip.style.display='block';
          tooltip.innerHTML = `<strong>Host #${n.id}</strong><div style="color:#b6c8e6;font-size:12px">Status: ${capitalize(n.status)}</div>`;
        });
        g.addEventListener('mousemove',(ev)=>{
          const rect = svg.getBoundingClientRect();
          tooltip.style.left = (ev.clientX - rect.left) + 'px';
          tooltip.style.top = (ev.clientY - rect.top) + 'px';
        });
        g.addEventListener('mouseleave', ()=> { tooltip.style.display='none' });

        g.addEventListener('click',(ev)=>{
          // click a node to simulate user action: if there is trojan, clicking tries to execute
          ev.stopPropagation();
          if(n.trojans>0){
            // click trojan attempts compromise based on trojanRate
            if(Math.random() < parseFloat(trojanRateInput.value)){
              n.status = 'compromised';
            } else {
              // maybe patch
              if(Math.random() < parseFloat(patchRateInput.value)) n.status = 'patched';
            }
            n.trojans = 0;
            updateVisual(n, status, trojanRect);
            updateStats();
          } else {
            // manually toggle compromised for demonstration
            n.status = n.status === 'compromised' ? 'healthy' : 'compromised';
            updateVisual(n, status, trojanRect);
            updateStats();
          }
        });

        svg.appendChild(g);
        n.elem = {g, circle:c, statusDot:status, trojanRect, label:lab};
        updateVisual(n, status, trojanRect);
      });

      updateStats();
    }

    function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1) }

    function updateVisual(n, statusDot, trojanRect){
      const col = n.status === 'healthy' ? '#10b981' :
                  n.status === 'infected' ? '#ef4444' :
                  n.status === 'compromised' ? '#f59e0b' :
                  n.status === 'patched' ? '#60a5fa' : '#9ca3af';
      statusDot.setAttribute('fill', col);
      trojanRect.setAttribute('opacity', n.trojans>0 ? '1' : '0');
      // circle pulse effect for infected
      if(n.status==='infected'){
        n.elem.circle.setAttribute('fill','#2a0b0b');
        n.elem.g.querySelector('circle').style.filter = 'drop-shadow(0 6px 18px rgba(239,68,68,0.12))';
      } else {
        n.elem.circle.setAttribute('fill','#0b1220');
        n.elem.g.querySelector('circle').style.filter = '';
      }
    }

    /* --- simulation tick logic --- */
    function simulationTick(){
      tick++;
      tickCountEl.textContent = tick;

      const p = params();

      // worms: infected attempt to infect neighbors automatically
      if(mode === 'worms'){
        const toInfect = [];
        nodes.forEach(n=>{
          if(n.status === 'infected'){
            // find neighbors
            const neigh = edges.filter(e => e.a===n.id || e.b===n.id).map(e => e.a===n.id?e.b:e.a);
            neigh.forEach(i=>{
              if(Math.random() < p.wormRate){
                // only healthy or patched can be infected (patched lower chance)
                if(nodes[i].status === 'healthy' || nodes[i].status === 'patched'){
                  toInfect.push(i);
                }
              }
            });
          }
        });
        toInfect.forEach(i=> nodes[i].status = 'infected');
      }

      // virus: more probabilistic spread via edges + latent compromise
      if(mode === 'virus'){
        const toInfect = [];
        nodes.forEach(n=>{
          if(n.status === 'infected' || n.status === 'compromised'){
            const neigh = edges.filter(e => e.a===n.id || e.b===n.id).map(e => e.a===n.id?e.b:e.a);
            neigh.forEach(i=>{
              if(Math.random() < (p.wormRate*0.6)){
                if(nodes[i].status === 'healthy') toInfect.push(i);
              }
            });
            // infected slowly becomes compromised over time
            if(n.status === 'infected' && Math.random() < 0.08) n.status = 'compromised';
          }
        });
        toInfect.forEach(i=> nodes[i].status = 'infected');
      }

      // trojan mode: infections originate from trojans on nodes (deployed by user)
      if(mode === 'trojan'){
        nodes.forEach(n=>{
          if(n.trojans>0 && n.status === 'healthy'){
            // each trojan has a chance to succeed per tick (simulating click/execution)
            if(Math.random() < p.trojanRate*0.25){
              n.status = 'compromised';
              n.trojans = 0;
            }
          }
        });
      }

      // patching
      nodes.forEach(n=>{
        if(Math.random() < p.patchRate){
          if(n.status === 'infected' || n.status === 'compromised'){
            n.status = 'patched';
          }
        }
      });

      // auto-seed if enabled
      if(p.autoSeed && Math.random() < 0.12){
        for(let r=0;r<p.autoSeedCount;r++){
          const healthy = nodes.filter(x=>x.status==='healthy');
          if(healthy.length>0){
            healthy[Math.floor(Math.random()*healthy.length)].status = 'infected';
          }
        }
      }

      // update visuals
      nodes.forEach(n => updateVisual(n, n.elem.statusDot, n.elem.trojanRect));
      updateStats();
      drawSpark();
    }

    /* --- controls & UI wiring --- */
    // mode buttons
    function setMode(m){
      mode = m;
      currentModeLabel.textContent = capitalize(m);
      for(const k in modeBtns) modeBtns[k].classList.remove('active');
      if(m === 'worms') modeBtns.worms.classList.add('active');
      if(m === 'trojan') modeBtns.trojan.classList.add('active');
      if(m === 'virus') modeBtns.virus.classList.add('active');

      // update info description
      if(m==='worms') modeInfo.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Worms — network propagation</div>
        <div class="small">Worms scan neighbors and automatically attempt lateral movement across edges. Adjust infection and patch rates to observe outcomes.</div>`;
      if(m==='trojan') modeInfo.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Trojan Horse — social engineering</div>
        <div class="small">Trojans rely on user action: deploy small files to hosts and click nodes to trigger the vector. Try deploying and clicking nodes.</div>`;
      if(m==='virus') modeInfo.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Virus — hybrid spread</div>
        <div class="small">Viruses propagate via edges slower but cause latent compromise. Watch infected hosts become compromised over time.</div>`;
    }

    modeBtns.worms.addEventListener('click', ()=> setMode('worms'));
    modeBtns.trojan.addEventListener('click', ()=> setMode('trojan'));
    modeBtns.virus.addEventListener('click', ()=> setMode('virus'));

    // slider labels
    wormRateInput.addEventListener('input', ()=> wormRateLabel.textContent = parseFloat(wormRateInput.value).toFixed(2));
    trojanRateInput.addEventListener('input', ()=> trojanRateLabel.textContent = parseFloat(trojanRateInput.value).toFixed(2));
    patchRateInput.addEventListener('input', ()=> patchRateLabel.textContent = parseFloat(patchRateInput.value).toFixed(2));
    speedRange.addEventListener('input', ()=> speedLabel.textContent = speedRange.value);
    netSizeRange.addEventListener('input', ()=> {
      // rebuild network immediately when user changes size for quicker feedback
      buildNetwork(parseInt(netSizeRange.value,10));
    });

    // auto seed count display
    autoSeedToggle.addEventListener('change', ()=> {
      autoSeedCount.textContent = autoSeedToggle.checked ? Math.max(1, Math.round(parseInt(netSizeRange.value,10)/20)) : '0';
    });

    // start / pause / reset
    startBtn.addEventListener('click', ()=>{
      if(!running){
        running = true;
        startLoop();
      }
    });
    pauseBtn.addEventListener('click', ()=> {
      running = false;
      if(timer) clearInterval(timer);
      timer = null;
    });
    resetBtn.addEventListener('click', ()=>{
      running = false;
      if(timer) clearInterval(timer);
      timer = null;
      tick = 0; tickCountEl.textContent='0';
      buildNetwork(parseInt(netSizeRange.value,10));
    });

    // seed infection: pick some healthy hosts and mark infected
    seedBtn.addEventListener('click', ()=>{
      const count = Math.max(1, Math.round(parseInt(netSizeRange.value,10)/20));
      const healthy = nodes.filter(n=> n.status==='healthy');
      for(let i=0;i<count && healthy.length>0;i++){
        const pick = healthy.splice(Math.floor(Math.random()*healthy.length),1)[0];
        nodes[pick.id].status = 'infected';
      }
      updateStats();
      renderNetwork();
    });

    // deploy trojan: add trojan files to some random nodes
    spawnTrojanBtn.addEventListener('click', ()=>{
      // add trojan to ~10% of nodes
      const count = Math.max(1, Math.round(nodes.length * 0.08));
      for(let i=0;i<count;i++){
        const pick = nodes[Math.floor(Math.random()*nodes.length)];
        pick.trojans += 1;
      }
      nodes.forEach(n => updateVisual(n, n.elem.statusDot, n.elem.trojanRect));
    });

    // clicking canvas deselect
    svg.addEventListener('click', ()=> tooltip.style.display='none');

    // simulation loop
    function startLoop(){
      if(timer) clearInterval(timer);
      const interval = parseInt(speedRange.value,10);
      timer = setInterval(()=>{
        simulationTick();
      }, interval);
    }

    /* --- stats & sparkline --- */
    let history = [];
    function updateStats(){
      const healthy = nodes.filter(n=>n.status==='healthy').length;
      const infected = nodes.filter(n=>n.status==='infected').length;
      const comp = nodes.filter(n=>n.status==='compromised').length;
      const patched = nodes.filter(n=>n.status==='patched').length;
      statHealthy.textContent = healthy;
      statInfected.textContent = infected;
      statCompromised.textContent = comp;
      statPatched.textContent = patched;

      history.push(infected + comp);
      if(history.length>60) history.shift();
      drawSpark();
    }

    function drawSpark(){
      const w = spark.width, h = spark.height;
      sctx.clearRect(0,0,w,h);
      // background faint
      sctx.fillStyle = 'rgba(255,255,255,0.02)';
      sctx.fillRect(0,0,w,h);

      if(history.length===0) return;
      const maxv = Math.max(...history,1);
      sctx.beginPath();
      for(let i=0;i<history.length;i++){
        const x = (i/(history.length-1)) * w;
        const y = h - (history[i]/maxv)*(h-6) - 2;
        if(i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
      }
      sctx.strokeStyle = 'rgba(239,68,68,0.9)';
      sctx.lineWidth = 2;
      sctx.stroke();

      // fill area
      sctx.lineTo(w, h); sctx.lineTo(0,h); sctx.closePath();
      sctx.fillStyle = 'rgba(239,68,68,0.08)';
      sctx.fill();
    }

    /* --- initialization --- */
    function init(){
      // set initial labels
      wormRateLabel.textContent = parseFloat(wormRateInput.value).toFixed(2);
      trojanRateLabel.textContent = parseFloat(trojanRateInput.value).toFixed(2);
      patchRateLabel.textContent = parseFloat(patchRateInput.value).toFixed(2);
      speedLabel.textContent = speedRange.value;
      autoSeedCount.textContent = autoSeedToggle.checked ? Math.max(1, Math.round(parseInt(netSizeRange.value,10)/20)) : '0';

      // build initial network
      buildNetwork(parseInt(netSizeRange.value,10));

      // seed initial infected if autoSeed true
      if(autoSeedToggle.checked){
        seedBtn.click();
      }

      // start small visual “breathing” for infected nodes
      setInterval(()=> {
        // subtle jitter for edges to give life
        edges.forEach(e => {
          // no change to coords — but could animate stroke or opacity
          if(Math.random()<0.02) e.elem.setAttribute('stroke-opacity', (0.03 + Math.random()*0.05).toString());
        });
      }, 600);
    }

    // initial run
    init();

    // expose for debug in console
    window.__sim = {nodes, edges, buildNetwork, simulationTick};
  </script>
</body>
</html>
